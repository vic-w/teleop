<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Fixed Stereo Images</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="debug-info" style="position: fixed; top: 10px; left: 10px; color: white; background: rgba(0, 0, 0, 0.5); padding: 10px; z-index: 1000;"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/VRButton.js';

        let xrRefSpace = null;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 启用 WebXR
        if ('xr' in navigator) {
            renderer.xr.enabled = true;
            document.body.appendChild(VRButton.createButton(renderer));
        }

        // 加载纹理
        const textureLoader = new THREE.TextureLoader();
        const textureLeft = textureLoader.load('left.png');
        const textureRight = textureLoader.load('right.png');

        // 创建左右眼平面
        const geometry = new THREE.PlaneGeometry(5, 5); // 平面大小
        const materialLeft = new THREE.MeshBasicMaterial({ map: textureLeft });
        const materialRight = new THREE.MeshBasicMaterial({ map: textureRight });

        const meshLeft = new THREE.Mesh(geometry, materialLeft);
        const meshRight = new THREE.Mesh(geometry, materialRight);

        // 将左右眼平面添加到场景中
        scene.add(meshLeft);
        scene.add(meshRight);

        // 设置渲染层级
        meshLeft.layers.set(1);  // 左眼层级
        meshRight.layers.set(2); // 右眼层级

        // 设置初始位置（距离相机一定距离）
        const distance = 5; // 图片距离相机的距离
        meshLeft.position.set(-0.5, 0, -distance); // 左眼图片位置
        meshRight.position.set(0.5, 0, -distance); // 右眼图片位置

        // 创建手部关节的几何体和材质
        const jointGeometry = new THREE.SphereGeometry(0.02, 16, 16); // 小球表示关节
        const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

        // 存储手部关节的网格
        const leftHandJoints = {};
        const rightHandJoints = {};

        // 初始化手部关节
        for (let i = 0; i < 25; i++) { // 每只手有25个关节
            const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
            leftHandJoints[i] = jointMesh;
            scene.add(jointMesh);
            jointMesh.position.set(0, 0, -3);
        }

        for (let i = 0; i < 25; i++) { // 每只手有25个关节
            const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
            rightHandJoints[i] = jointMesh;
            scene.add(jointMesh);
            jointMesh.position.set(0, 0, -3);
        }

        function logToScreen(message) {
            const debugInfo = document.getElementById('debug-info');
            debugInfo.innerText += (message + '\n');
        }

        logToScreen('WebXR session started');

        // 渲染帧回调函数
        const onXRFrame = (timestamp, frame) => {
            // 获取XR会话的相机视图
            const xrCamera = renderer.xr.getCamera(camera);

            // 获取相机的世界位置和方向
            const cameraWorldPosition = new THREE.Vector3();
            const cameraWorldQuaternion = new THREE.Quaternion();
            xrCamera.getWorldPosition(cameraWorldPosition);
            xrCamera.getWorldQuaternion(cameraWorldQuaternion);

            // 计算图片的目标位置（相机前方固定距离）
            const offset = new THREE.Vector3(0, 0, -distance);
            offset.applyQuaternion(cameraWorldQuaternion);

            // 更新左右眼图片的位置和方向
            meshLeft.position.copy(cameraWorldPosition).add(offset);
            meshLeft.quaternion.copy(cameraWorldQuaternion);

            meshRight.position.copy(cameraWorldPosition).add(offset);
            meshRight.quaternion.copy(cameraWorldQuaternion);

            const session = renderer.xr.getSession();
            if(session){
                if(session.inputSources){
                    for (const inputSource of session.inputSources) {
                        if (inputSource.hand) {
                            const hand = inputSource.hand;
                            const joints = inputSource.handedness === 'left' ? leftHandJoints : rightHandJoints;

                            // 更新手部关节位置
                            let i = 0;
                            for (const joint of hand.values()) {
                                 const jointMesh = joints[i];

                                 if (!xrRefSpace) {
                                    session.requestReferenceSpace('local').then((refSpace) => {
                                        xrRefSpace = refSpace;
                                    });
                                 }

                                 // 如果有xrRefSpace，获取手部关节的位置
                                 if (xrRefSpace) {
                                    const jointPose = frame.getJointPose(joint, xrRefSpace);

                                    // logToScreen(String('x:'+ jointPose.transform.position.x));
                                    // logToScreen(String('y:'+ jointPose.transform.position.y));
                                    // logToScreen(String('z:'+ jointPose.transform.position.z));

                                    // 将手部关节的位置从头盔坐标系转换为世界坐标系
                                    const jointLocalPosition = new THREE.Vector3(
                                        jointPose.transform.position.x,
                                        jointPose.transform.position.y,
                                        jointPose.transform.position.z
                                    );

                                    // 将关节的旋转从头盔坐标系转换到世界坐标系
                                    const jointLocalRotation = new THREE.Quaternion(
                                        jointPose.transform.orientation.x,
                                        jointPose.transform.orientation.y,
                                        jointPose.transform.orientation.z,
                                        jointPose.transform.orientation.w
                                    );

                                    // 先应用旋转，再应用平移
                                    jointLocalPosition.applyQuaternion(cameraWorldQuaternion); // 将关节的局部位置旋转到世界坐标系
                                    jointLocalPosition.add(cameraWorldPosition); // 应用相机的世界位置（平移）

                                    // 最后更新关节的旋转：先应用相机的旋转，再应用关节的旋转
                                    jointLocalRotation.multiply(cameraWorldQuaternion);

                                    // 更新手部关节的位置和旋转
                                    jointMesh.position.set(jointLocalPosition.x, jointLocalPosition.y, jointLocalPosition.z);
                                    jointMesh.quaternion.set(jointLocalRotation.x, jointLocalRotation.y, jointLocalRotation.z, jointLocalRotation.w);
                                 }
                                i++;
                            }
                        }
                    }

                }

            }

            // 渲染场景
            renderer.render(scene, camera);
        };

        // 设置渲染循环
        renderer.setAnimationLoop(onXRFrame);

        // 处理窗口大小变化
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
